/* tslint:disable */
/* eslint-disable */
/**
 * Unleash API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.14.0-beta.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddonSchema,
  AddonsSchema,
  ApiTokenSchema,
  ApiTokensSchema,
  ApplicationSchema,
  ApplicationsSchema,
  CloneFeatureSchema,
  ConstraintSchema,
  ContextFieldSchema,
  CreateApiTokenSchema,
  CreateFeatureSchema,
  CreateFeatureStrategySchema,
  CreateUserSchema,
  EnvironmentSchema,
  EventsSchema,
  FeatureEnvironmentSchema,
  FeatureEventsSchema,
  FeatureMetricsSchema,
  FeatureSchema,
  FeatureStrategySchema,
  FeatureTypesSchema,
  FeatureUsageSchema,
  FeatureVariantsSchema,
  FeaturesSchema,
  FeedbackSchema,
  HealthOverviewSchema,
  HealthReportSchema,
  IdSchema,
  MeSchema,
  NameSchema,
  PasswordSchema,
  PatchSchema,
  PlaygroundRequestSchema,
  PlaygroundResponseSchema,
  ProjectEnvironmentSchema,
  ProjectsSchema,
  ResetPasswordSchema,
  SplashSchema,
  StateSchema,
  StrategiesSchema,
  StrategySchema,
  TagSchema,
  TagTypeSchema,
  TagTypesSchema,
  TagWithVersionSchema,
  TagsSchema,
  UiConfigSchema,
  UpdateApiTokenSchema,
  UpdateFeatureSchema,
  UpdateFeatureStrategySchema,
  UpdateTagTypeSchema,
  UpdateUserSchema,
  UpsertContextFieldSchema,
  UpsertStrategySchema,
  UserSchema,
  UsersSchema,
  ValidateTagTypeSchema,
  VariantSchema,
} from '../models';
import {
    AddonSchemaFromJSON,
    AddonSchemaToJSON,
    AddonsSchemaFromJSON,
    AddonsSchemaToJSON,
    ApiTokenSchemaFromJSON,
    ApiTokenSchemaToJSON,
    ApiTokensSchemaFromJSON,
    ApiTokensSchemaToJSON,
    ApplicationSchemaFromJSON,
    ApplicationSchemaToJSON,
    ApplicationsSchemaFromJSON,
    ApplicationsSchemaToJSON,
    CloneFeatureSchemaFromJSON,
    CloneFeatureSchemaToJSON,
    ConstraintSchemaFromJSON,
    ConstraintSchemaToJSON,
    ContextFieldSchemaFromJSON,
    ContextFieldSchemaToJSON,
    CreateApiTokenSchemaFromJSON,
    CreateApiTokenSchemaToJSON,
    CreateFeatureSchemaFromJSON,
    CreateFeatureSchemaToJSON,
    CreateFeatureStrategySchemaFromJSON,
    CreateFeatureStrategySchemaToJSON,
    CreateUserSchemaFromJSON,
    CreateUserSchemaToJSON,
    EnvironmentSchemaFromJSON,
    EnvironmentSchemaToJSON,
    EventsSchemaFromJSON,
    EventsSchemaToJSON,
    FeatureEnvironmentSchemaFromJSON,
    FeatureEnvironmentSchemaToJSON,
    FeatureEventsSchemaFromJSON,
    FeatureEventsSchemaToJSON,
    FeatureMetricsSchemaFromJSON,
    FeatureMetricsSchemaToJSON,
    FeatureSchemaFromJSON,
    FeatureSchemaToJSON,
    FeatureStrategySchemaFromJSON,
    FeatureStrategySchemaToJSON,
    FeatureTypesSchemaFromJSON,
    FeatureTypesSchemaToJSON,
    FeatureUsageSchemaFromJSON,
    FeatureUsageSchemaToJSON,
    FeatureVariantsSchemaFromJSON,
    FeatureVariantsSchemaToJSON,
    FeaturesSchemaFromJSON,
    FeaturesSchemaToJSON,
    FeedbackSchemaFromJSON,
    FeedbackSchemaToJSON,
    HealthOverviewSchemaFromJSON,
    HealthOverviewSchemaToJSON,
    HealthReportSchemaFromJSON,
    HealthReportSchemaToJSON,
    IdSchemaFromJSON,
    IdSchemaToJSON,
    MeSchemaFromJSON,
    MeSchemaToJSON,
    NameSchemaFromJSON,
    NameSchemaToJSON,
    PasswordSchemaFromJSON,
    PasswordSchemaToJSON,
    PatchSchemaFromJSON,
    PatchSchemaToJSON,
    PlaygroundRequestSchemaFromJSON,
    PlaygroundRequestSchemaToJSON,
    PlaygroundResponseSchemaFromJSON,
    PlaygroundResponseSchemaToJSON,
    ProjectEnvironmentSchemaFromJSON,
    ProjectEnvironmentSchemaToJSON,
    ProjectsSchemaFromJSON,
    ProjectsSchemaToJSON,
    ResetPasswordSchemaFromJSON,
    ResetPasswordSchemaToJSON,
    SplashSchemaFromJSON,
    SplashSchemaToJSON,
    StateSchemaFromJSON,
    StateSchemaToJSON,
    StrategiesSchemaFromJSON,
    StrategiesSchemaToJSON,
    StrategySchemaFromJSON,
    StrategySchemaToJSON,
    TagSchemaFromJSON,
    TagSchemaToJSON,
    TagTypeSchemaFromJSON,
    TagTypeSchemaToJSON,
    TagTypesSchemaFromJSON,
    TagTypesSchemaToJSON,
    TagWithVersionSchemaFromJSON,
    TagWithVersionSchemaToJSON,
    TagsSchemaFromJSON,
    TagsSchemaToJSON,
    UiConfigSchemaFromJSON,
    UiConfigSchemaToJSON,
    UpdateApiTokenSchemaFromJSON,
    UpdateApiTokenSchemaToJSON,
    UpdateFeatureSchemaFromJSON,
    UpdateFeatureSchemaToJSON,
    UpdateFeatureStrategySchemaFromJSON,
    UpdateFeatureStrategySchemaToJSON,
    UpdateTagTypeSchemaFromJSON,
    UpdateTagTypeSchemaToJSON,
    UpdateUserSchemaFromJSON,
    UpdateUserSchemaToJSON,
    UpsertContextFieldSchemaFromJSON,
    UpsertContextFieldSchemaToJSON,
    UpsertStrategySchemaFromJSON,
    UpsertStrategySchemaToJSON,
    UserSchemaFromJSON,
    UserSchemaToJSON,
    UsersSchemaFromJSON,
    UsersSchemaToJSON,
    ValidateTagTypeSchemaFromJSON,
    ValidateTagTypeSchemaToJSON,
    VariantSchemaFromJSON,
    VariantSchemaToJSON,
} from '../models';

export interface ImportRequest {
    requestBody: { [key: string]: any; };
}

export interface AddEnvironmentToProjectRequest {
    projectId: string;
    projectEnvironmentSchema: ProjectEnvironmentSchema;
}

export interface AddFeatureStrategyRequest {
    projectId: string;
    featureName: string;
    environment: string;
    createFeatureStrategySchema: CreateFeatureStrategySchema;
}

export interface AddTagRequest {
    featureName: string;
    tagSchema: TagSchema;
}

export interface ArchiveFeatureRequest {
    projectId: string;
    featureName: string;
}

export interface ChangeMyPasswordRequest {
    passwordSchema: PasswordSchema;
}

export interface ChangeUserPasswordRequest {
    id: string;
    passwordSchema: PasswordSchema;
}

export interface CloneFeatureRequest {
    projectId: string;
    featureName: string;
    cloneFeatureSchema: CloneFeatureSchema;
}

export interface CreateAddonRequest {
    addonSchema: AddonSchema;
}

export interface CreateApiTokenRequest {
    createApiTokenSchema: CreateApiTokenSchema;
}

export interface CreateApplicationRequest {
    appName: string;
    applicationSchema: ApplicationSchema;
}

export interface CreateContextFieldRequest {
    upsertContextFieldSchema: UpsertContextFieldSchema;
}

export interface CreateFeatureRequest {
    projectId: string;
    createFeatureSchema: CreateFeatureSchema;
}

export interface CreateFeedbackRequest {
    feedbackSchema: FeedbackSchema;
}

export interface CreateStrategyRequest {
    upsertStrategySchema: UpsertStrategySchema;
}

export interface CreateTagRequest {
    tagSchema: TagSchema;
}

export interface CreateTagTypeRequest {
    tagTypeSchema: TagTypeSchema;
}

export interface CreateUserRequest {
    createUserSchema: CreateUserSchema;
}

export interface DeleteAddonRequest {
    id: string;
}

export interface DeleteApiTokenRequest {
    token: string;
}

export interface DeleteApplicationRequest {
    appName: string;
}

export interface DeleteContextFieldRequest {
    contextField: string;
}

export interface DeleteFeatureRequest {
    featureName: string;
}

export interface DeleteFeatureStrategyRequest {
    projectId: string;
    featureName: string;
    environment: string;
    strategyId: string;
}

export interface DeleteTagRequest {
    type: string;
    value: string;
}

export interface DeleteTagTypeRequest {
    name: string;
}

export interface DeleteUserRequest {
    id: string;
}

export interface DeprecateStrategyRequest {
    strategyName: string;
}

export interface GetAddonRequest {
    id: string;
}

export interface GetApplicationRequest {
    appName: string;
}

export interface GetArchivedFeaturesByProjectIdRequest {
    projectId: string;
}

export interface GetContextFieldRequest {
    contextField: string;
}

export interface GetEnvironmentRequest {
    name: string;
}

export interface GetEventsRequest {
    project?: string;
}

export interface GetEventsForToggleRequest {
    featureName: string;
}

export interface GetFeatureRequest {
    projectId: string;
    featureName: string;
}

export interface GetFeatureEnvironmentRequest {
    projectId: string;
    featureName: string;
    environment: string;
}

export interface GetFeatureStrategiesRequest {
    projectId: string;
    featureName: string;
    environment: string;
}

export interface GetFeatureStrategyRequest {
    projectId: string;
    featureName: string;
    environment: string;
    strategyId: string;
}

export interface GetFeatureUsageSummaryRequest {
    name: string;
}

export interface GetFeatureVariantsRequest {
    projectId: string;
    featureName: string;
}

export interface GetFeaturesRequest {
    projectId: string;
}

export interface GetPlaygroundRequest {
    playgroundRequestSchema: PlaygroundRequestSchema;
}

export interface GetProjectHealthOverviewRequest {
    projectId: string;
}

export interface GetProjectHealthReportRequest {
    projectId: string;
}

export interface GetRawFeatureMetricsRequest {
    name: string;
}

export interface GetStrategyRequest {
    name: string;
}

export interface GetTagRequest {
    type: string;
    value: string;
}

export interface GetTagTypeRequest {
    name: string;
}

export interface GetTagsByTypeRequest {
    type: string;
}

export interface GetUserRequest {
    id: string;
}

export interface ListTagsRequest {
    featureName: string;
}

export interface OverwriteFeatureVariantsRequest {
    projectId: string;
    featureName: string;
    variantSchema: Array<VariantSchema>;
}

export interface PatchFeatureRequest {
    projectId: string;
    featureName: string;
    patchSchema: Array<PatchSchema>;
}

export interface PatchFeatureStrategyRequest {
    projectId: string;
    featureName: string;
    environment: string;
    strategyId: string;
    patchSchema: Array<PatchSchema>;
}

export interface PatchFeatureVariantsRequest {
    projectId: string;
    featureName: string;
    patchSchema: Array<PatchSchema>;
}

export interface ReactivateStrategyRequest {
    strategyName: string;
}

export interface RemoveEnvironmentFromProjectRequest {
    projectId: string;
    environment: string;
}

export interface RemoveStrategyRequest {
    name: string;
}

export interface RemoveTagRequest {
    featureName: string;
    type: string;
    value: string;
}

export interface ResetUserPasswordRequest {
    idSchema: IdSchema;
}

export interface ReviveFeatureRequest {
    featureName: string;
}

export interface ToggleEnvironmentOffRequest {
    name: string;
}

export interface ToggleEnvironmentOnRequest {
    name: string;
}

export interface ToggleFeatureEnvironmentOffRequest {
    projectId: string;
    featureName: string;
    environment: string;
}

export interface ToggleFeatureEnvironmentOnRequest {
    projectId: string;
    featureName: string;
    environment: string;
}

export interface UpdateAddonRequest {
    id: string;
    addonSchema: AddonSchema;
}

export interface UpdateApiTokenRequest {
    token: string;
    updateApiTokenSchema: UpdateApiTokenSchema;
}

export interface UpdateContextFieldRequest {
    contextField: string;
    upsertContextFieldSchema: UpsertContextFieldSchema;
}

export interface UpdateFeatureRequest {
    projectId: string;
    featureName: string;
    updateFeatureSchema: UpdateFeatureSchema;
}

export interface UpdateFeatureStrategyRequest {
    projectId: string;
    featureName: string;
    environment: string;
    strategyId: string;
    updateFeatureStrategySchema: UpdateFeatureStrategySchema;
}

export interface UpdateFeedbackRequest {
    id: string;
    feedbackSchema: FeedbackSchema;
}

export interface UpdateSortOrderRequest {
    requestBody: { [key: string]: number; };
}

export interface UpdateSplashSettingsRequest {
    id: string;
}

export interface UpdateStrategyRequest {
    strategyName: string;
    upsertStrategySchema: UpsertStrategySchema;
}

export interface UpdateTagTypeRequest {
    name: string;
    updateTagTypeSchema: UpdateTagTypeSchema;
}

export interface UpdateUserRequest {
    id: string;
    updateUserSchema: UpdateUserSchema;
}

export interface ValidateRequest {
    nameSchema: NameSchema;
}

export interface ValidateConstraintRequest {
    constraintSchema: ConstraintSchema;
}

export interface ValidateTagTypeRequest {
    tagTypeSchema: TagTypeSchema;
}

export interface ValidateUserPasswordRequest {
    passwordSchema: PasswordSchema;
}

/**
 *
 */
export class AdminApi extends runtime.BaseAPI {

    /**
     */
    async _exportRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StateSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/state/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StateSchemaFromJSON(jsonValue));
    }

    /**
     */
    async _export(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StateSchema> {
        const response = await this._exportRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async _importRaw(requestParameters: ImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling _import.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/state/import`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async _import(requestParameters: ImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this._importRaw(requestParameters, initOverrides);
    }

    /**
     */
    async addEnvironmentToProjectRaw(requestParameters: AddEnvironmentToProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling addEnvironmentToProject.');
        }

        if (requestParameters.projectEnvironmentSchema === null || requestParameters.projectEnvironmentSchema === undefined) {
            throw new runtime.RequiredError('projectEnvironmentSchema','Required parameter requestParameters.projectEnvironmentSchema was null or undefined when calling addEnvironmentToProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/environments`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectEnvironmentSchemaToJSON(requestParameters.projectEnvironmentSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async addEnvironmentToProject(requestParameters: AddEnvironmentToProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addEnvironmentToProjectRaw(requestParameters, initOverrides);
    }

    /**
     */
    async addFeatureStrategyRaw(requestParameters: AddFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureStrategySchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling addFeatureStrategy.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling addFeatureStrategy.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling addFeatureStrategy.');
        }

        if (requestParameters.createFeatureStrategySchema === null || requestParameters.createFeatureStrategySchema === undefined) {
            throw new runtime.RequiredError('createFeatureStrategySchema','Required parameter requestParameters.createFeatureStrategySchema was null or undefined when calling addFeatureStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFeatureStrategySchemaToJSON(requestParameters.createFeatureStrategySchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureStrategySchemaFromJSON(jsonValue));
    }

    /**
     */
    async addFeatureStrategy(requestParameters: AddFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureStrategySchema> {
        const response = await this.addFeatureStrategyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async addTagRaw(requestParameters: AddTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagSchema>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling addTag.');
        }

        if (requestParameters.tagSchema === null || requestParameters.tagSchema === undefined) {
            throw new runtime.RequiredError('tagSchema','Required parameter requestParameters.tagSchema was null or undefined when calling addTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/features/{featureName}/tags`.replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TagSchemaToJSON(requestParameters.tagSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagSchemaFromJSON(jsonValue));
    }

    /**
     */
    async addTag(requestParameters: AddTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagSchema> {
        const response = await this.addTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async archiveFeatureRaw(requestParameters: ArchiveFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling archiveFeature.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling archiveFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async archiveFeature(requestParameters: ArchiveFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.archiveFeatureRaw(requestParameters, initOverrides);
    }

    /**
     */
    async changeMyPasswordRaw(requestParameters: ChangeMyPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.passwordSchema === null || requestParameters.passwordSchema === undefined) {
            throw new runtime.RequiredError('passwordSchema','Required parameter requestParameters.passwordSchema was null or undefined when calling changeMyPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user/change-password`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordSchemaToJSON(requestParameters.passwordSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async changeMyPassword(requestParameters: ChangeMyPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.changeMyPasswordRaw(requestParameters, initOverrides);
    }

    /**
     */
    async changeUserPasswordRaw(requestParameters: ChangeUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling changeUserPassword.');
        }

        if (requestParameters.passwordSchema === null || requestParameters.passwordSchema === undefined) {
            throw new runtime.RequiredError('passwordSchema','Required parameter requestParameters.passwordSchema was null or undefined when calling changeUserPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/{id}/change-password`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordSchemaToJSON(requestParameters.passwordSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async changeUserPassword(requestParameters: ChangeUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.changeUserPasswordRaw(requestParameters, initOverrides);
    }

    /**
     */
    async cloneFeatureRaw(requestParameters: CloneFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling cloneFeature.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling cloneFeature.');
        }

        if (requestParameters.cloneFeatureSchema === null || requestParameters.cloneFeatureSchema === undefined) {
            throw new runtime.RequiredError('cloneFeatureSchema','Required parameter requestParameters.cloneFeatureSchema was null or undefined when calling cloneFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/clone`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CloneFeatureSchemaToJSON(requestParameters.cloneFeatureSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async cloneFeature(requestParameters: CloneFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.cloneFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createAddonRaw(requestParameters: CreateAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddonSchema>> {
        if (requestParameters.addonSchema === null || requestParameters.addonSchema === undefined) {
            throw new runtime.RequiredError('addonSchema','Required parameter requestParameters.addonSchema was null or undefined when calling createAddon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/addons`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddonSchemaToJSON(requestParameters.addonSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddonSchemaFromJSON(jsonValue));
    }

    /**
     */
    async createAddon(requestParameters: CreateAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddonSchema> {
        const response = await this.createAddonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createApiTokenRaw(requestParameters: CreateApiTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiTokenSchema>> {
        if (requestParameters.createApiTokenSchema === null || requestParameters.createApiTokenSchema === undefined) {
            throw new runtime.RequiredError('createApiTokenSchema','Required parameter requestParameters.createApiTokenSchema was null or undefined when calling createApiToken.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/api-tokens`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateApiTokenSchemaToJSON(requestParameters.createApiTokenSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiTokenSchemaFromJSON(jsonValue));
    }

    /**
     */
    async createApiToken(requestParameters: CreateApiTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiTokenSchema> {
        const response = await this.createApiTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createApplicationRaw(requestParameters: CreateApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appName === null || requestParameters.appName === undefined) {
            throw new runtime.RequiredError('appName','Required parameter requestParameters.appName was null or undefined when calling createApplication.');
        }

        if (requestParameters.applicationSchema === null || requestParameters.applicationSchema === undefined) {
            throw new runtime.RequiredError('applicationSchema','Required parameter requestParameters.applicationSchema was null or undefined when calling createApplication.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/metrics/applications/{appName}`.replace(`{${"appName"}}`, encodeURIComponent(String(requestParameters.appName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApplicationSchemaToJSON(requestParameters.applicationSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async createApplication(requestParameters: CreateApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createApplicationRaw(requestParameters, initOverrides);
    }

    /**
     */
    async createContextFieldRaw(requestParameters: CreateContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.upsertContextFieldSchema === null || requestParameters.upsertContextFieldSchema === undefined) {
            throw new runtime.RequiredError('upsertContextFieldSchema','Required parameter requestParameters.upsertContextFieldSchema was null or undefined when calling createContextField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/context`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertContextFieldSchemaToJSON(requestParameters.upsertContextFieldSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async createContextField(requestParameters: CreateContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createContextFieldRaw(requestParameters, initOverrides);
    }

    /**
     */
    async createFeatureRaw(requestParameters: CreateFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling createFeature.');
        }

        if (requestParameters.createFeatureSchema === null || requestParameters.createFeatureSchema === undefined) {
            throw new runtime.RequiredError('createFeatureSchema','Required parameter requestParameters.createFeatureSchema was null or undefined when calling createFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFeatureSchemaToJSON(requestParameters.createFeatureSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async createFeature(requestParameters: CreateFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.createFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createFeedbackRaw(requestParameters: CreateFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeedbackSchema>> {
        if (requestParameters.feedbackSchema === null || requestParameters.feedbackSchema === undefined) {
            throw new runtime.RequiredError('feedbackSchema','Required parameter requestParameters.feedbackSchema was null or undefined when calling createFeedback.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/feedback`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FeedbackSchemaToJSON(requestParameters.feedbackSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeedbackSchemaFromJSON(jsonValue));
    }

    /**
     */
    async createFeedback(requestParameters: CreateFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeedbackSchema> {
        const response = await this.createFeedbackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createStrategyRaw(requestParameters: CreateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.upsertStrategySchema === null || requestParameters.upsertStrategySchema === undefined) {
            throw new runtime.RequiredError('upsertStrategySchema','Required parameter requestParameters.upsertStrategySchema was null or undefined when calling createStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertStrategySchemaToJSON(requestParameters.upsertStrategySchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async createStrategy(requestParameters: CreateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createStrategyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async createTagRaw(requestParameters: CreateTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tagSchema === null || requestParameters.tagSchema === undefined) {
            throw new runtime.RequiredError('tagSchema','Required parameter requestParameters.tagSchema was null or undefined when calling createTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TagSchemaToJSON(requestParameters.tagSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async createTag(requestParameters: CreateTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createTagRaw(requestParameters, initOverrides);
    }

    /**
     */
    async createTagTypeRaw(requestParameters: CreateTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagTypeSchema>> {
        if (requestParameters.tagTypeSchema === null || requestParameters.tagTypeSchema === undefined) {
            throw new runtime.RequiredError('tagTypeSchema','Required parameter requestParameters.tagTypeSchema was null or undefined when calling createTagType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tag-types`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TagTypeSchemaToJSON(requestParameters.tagTypeSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagTypeSchemaFromJSON(jsonValue));
    }

    /**
     */
    async createTagType(requestParameters: CreateTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagTypeSchema> {
        const response = await this.createTagTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSchema>> {
        if (requestParameters.createUserSchema === null || requestParameters.createUserSchema === undefined) {
            throw new runtime.RequiredError('createUserSchema','Required parameter requestParameters.createUserSchema was null or undefined when calling createUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateUserSchemaToJSON(requestParameters.createUserSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSchemaFromJSON(jsonValue));
    }

    /**
     */
    async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSchema> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async deleteAddonRaw(requestParameters: DeleteAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteAddon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/addons/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteAddon(requestParameters: DeleteAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAddonRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteApiTokenRaw(requestParameters: DeleteApiTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteApiToken.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/api-tokens/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteApiToken(requestParameters: DeleteApiTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiTokenRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteApplicationRaw(requestParameters: DeleteApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appName === null || requestParameters.appName === undefined) {
            throw new runtime.RequiredError('appName','Required parameter requestParameters.appName was null or undefined when calling deleteApplication.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/metrics/applications/{appName}`.replace(`{${"appName"}}`, encodeURIComponent(String(requestParameters.appName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteApplication(requestParameters: DeleteApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApplicationRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteContextFieldRaw(requestParameters: DeleteContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contextField === null || requestParameters.contextField === undefined) {
            throw new runtime.RequiredError('contextField','Required parameter requestParameters.contextField was null or undefined when calling deleteContextField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/context/{contextField}`.replace(`{${"contextField"}}`, encodeURIComponent(String(requestParameters.contextField))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteContextField(requestParameters: DeleteContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteContextFieldRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteFeatureRaw(requestParameters: DeleteFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling deleteFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/archive/{featureName}`.replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteFeature(requestParameters: DeleteFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFeatureRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteFeatureStrategyRaw(requestParameters: DeleteFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling deleteFeatureStrategy.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling deleteFeatureStrategy.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling deleteFeatureStrategy.');
        }

        if (requestParameters.strategyId === null || requestParameters.strategyId === undefined) {
            throw new runtime.RequiredError('strategyId','Required parameter requestParameters.strategyId was null or undefined when calling deleteFeatureStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))).replace(`{${"strategyId"}}`, encodeURIComponent(String(requestParameters.strategyId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteFeatureStrategy(requestParameters: DeleteFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFeatureStrategyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteTagRaw(requestParameters: DeleteTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteTag.');
        }

        if (requestParameters.value === null || requestParameters.value === undefined) {
            throw new runtime.RequiredError('value','Required parameter requestParameters.value was null or undefined when calling deleteTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tags/{type}/{value}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"value"}}`, encodeURIComponent(String(requestParameters.value))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteTag(requestParameters: DeleteTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTagRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteTagTypeRaw(requestParameters: DeleteTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteTagType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tag-types/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteTagType(requestParameters: DeleteTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTagTypeRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deprecateStrategyRaw(requestParameters: DeprecateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.strategyName === null || requestParameters.strategyName === undefined) {
            throw new runtime.RequiredError('strategyName','Required parameter requestParameters.strategyName was null or undefined when calling deprecateStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies/{strategyName}/deprecate`.replace(`{${"strategyName"}}`, encodeURIComponent(String(requestParameters.strategyName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deprecateStrategy(requestParameters: DeprecateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deprecateStrategyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async getAddonRaw(requestParameters: GetAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddonSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAddon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/addons/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddonSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getAddon(requestParameters: GetAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddonSchema> {
        const response = await this.getAddonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getAddonsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddonsSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/addons`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddonsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getAddons(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddonsSchema> {
        const response = await this.getAddonsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getAllApiTokensRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiTokensSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/api-tokens`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiTokensSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getAllApiTokens(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiTokensSchema> {
        const response = await this.getAllApiTokensRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getAllEnvironmentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/environments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getAllEnvironments(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAllEnvironmentsRaw(initOverrides);
    }

    /**
     */
    async getAllFeatureTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureTypesSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/feature-types`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureTypesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getAllFeatureTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureTypesSchema> {
        const response = await this.getAllFeatureTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getAllStrategiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StrategiesSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StrategiesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getAllStrategies(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StrategiesSchema> {
        const response = await this.getAllStrategiesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getAllTogglesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeaturesSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/features`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeaturesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getAllToggles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeaturesSchema> {
        const response = await this.getAllTogglesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getApplicationRaw(requestParameters: GetApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationSchema>> {
        if (requestParameters.appName === null || requestParameters.appName === undefined) {
            throw new runtime.RequiredError('appName','Required parameter requestParameters.appName was null or undefined when calling getApplication.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/metrics/applications/{appName}`.replace(`{${"appName"}}`, encodeURIComponent(String(requestParameters.appName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getApplication(requestParameters: GetApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationSchema> {
        const response = await this.getApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getApplicationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationsSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/metrics/applications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getApplications(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationsSchema> {
        const response = await this.getApplicationsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getArchivedFeaturesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeaturesSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/archive/features`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeaturesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getArchivedFeatures(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeaturesSchema> {
        const response = await this.getArchivedFeaturesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getArchivedFeaturesByProjectIdRaw(requestParameters: GetArchivedFeaturesByProjectIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeaturesSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getArchivedFeaturesByProjectId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/archive/features/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeaturesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getArchivedFeaturesByProjectId(requestParameters: GetArchivedFeaturesByProjectIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeaturesSchema> {
        const response = await this.getArchivedFeaturesByProjectIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getContextFieldRaw(requestParameters: GetContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContextFieldSchema>> {
        if (requestParameters.contextField === null || requestParameters.contextField === undefined) {
            throw new runtime.RequiredError('contextField','Required parameter requestParameters.contextField was null or undefined when calling getContextField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/context/{contextField}`.replace(`{${"contextField"}}`, encodeURIComponent(String(requestParameters.contextField))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContextFieldSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getContextField(requestParameters: GetContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContextFieldSchema> {
        const response = await this.getContextFieldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getContextFieldsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContextFieldSchema>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/context`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContextFieldSchemaFromJSON));
    }

    /**
     */
    async getContextFields(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContextFieldSchema>> {
        const response = await this.getContextFieldsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getEnvironmentRaw(requestParameters: GetEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentSchema>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getEnvironment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/environments/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getEnvironment(requestParameters: GetEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentSchema> {
        const response = await this.getEnvironmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns **the last 100** from the Unleash instance when called without a query parameter. When called with a `project` parameter, returns **all events** for the specified project.  If the provided project does not exist, the list of events will be empty.
     * Get the most recent events from the Unleash instance or all events related to a project.
     */
    async getEventsRaw(requestParameters: GetEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventsSchema>> {
        const queryParameters: any = {};

        if (requestParameters.project !== undefined) {
            queryParameters['project'] = requestParameters.project;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventsSchemaFromJSON(jsonValue));
    }

    /**
     * Returns **the last 100** from the Unleash instance when called without a query parameter. When called with a `project` parameter, returns **all events** for the specified project.  If the provided project does not exist, the list of events will be empty.
     * Get the most recent events from the Unleash instance or all events related to a project.
     */
    async getEvents(requestParameters: GetEventsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventsSchema> {
        const response = await this.getEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all events related to the specified feature toggle. If the feature toggle does not exist, the list of events will be empty.
     * Get all events related to a specific feature toggle.
     */
    async getEventsForToggleRaw(requestParameters: GetEventsForToggleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureEventsSchema>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling getEventsForToggle.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/events/{featureName}`.replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureEventsSchemaFromJSON(jsonValue));
    }

    /**
     * Returns all events related to the specified feature toggle. If the feature toggle does not exist, the list of events will be empty.
     * Get all events related to a specific feature toggle.
     */
    async getEventsForToggle(requestParameters: GetEventsForToggleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureEventsSchema> {
        const response = await this.getEventsForToggleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeatureRaw(requestParameters: GetFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getFeature.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling getFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeature(requestParameters: GetFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.getFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeatureEnvironmentRaw(requestParameters: GetFeatureEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureEnvironmentSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getFeatureEnvironment.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling getFeatureEnvironment.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling getFeatureEnvironment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureEnvironmentSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeatureEnvironment(requestParameters: GetFeatureEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureEnvironmentSchema> {
        const response = await this.getFeatureEnvironmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeatureStrategiesRaw(requestParameters: GetFeatureStrategiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureStrategySchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getFeatureStrategies.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling getFeatureStrategies.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling getFeatureStrategies.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureStrategySchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeatureStrategies(requestParameters: GetFeatureStrategiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureStrategySchema> {
        const response = await this.getFeatureStrategiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeatureStrategyRaw(requestParameters: GetFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureStrategySchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getFeatureStrategy.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling getFeatureStrategy.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling getFeatureStrategy.');
        }

        if (requestParameters.strategyId === null || requestParameters.strategyId === undefined) {
            throw new runtime.RequiredError('strategyId','Required parameter requestParameters.strategyId was null or undefined when calling getFeatureStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))).replace(`{${"strategyId"}}`, encodeURIComponent(String(requestParameters.strategyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureStrategySchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeatureStrategy(requestParameters: GetFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureStrategySchema> {
        const response = await this.getFeatureStrategyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeatureUsageSummaryRaw(requestParameters: GetFeatureUsageSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureUsageSchema>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getFeatureUsageSummary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/client-metrics/features/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureUsageSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeatureUsageSummary(requestParameters: GetFeatureUsageSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureUsageSchema> {
        const response = await this.getFeatureUsageSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeatureVariantsRaw(requestParameters: GetFeatureVariantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureVariantsSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getFeatureVariants.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling getFeatureVariants.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/variants`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureVariantsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeatureVariants(requestParameters: GetFeatureVariantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureVariantsSchema> {
        const response = await this.getFeatureVariantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFeaturesRaw(requestParameters: GetFeaturesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeaturesSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getFeatures.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeaturesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getFeatures(requestParameters: GetFeaturesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeaturesSchema> {
        const response = await this.getFeaturesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getMeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MeSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MeSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getMe(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MeSchema> {
        const response = await this.getMeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Use the provided `context`, `environment`, and `projects` to evaluate toggles on this Unleash instance. Returns a list of all toggles that match the parameters and what they evaluate to. The response also contains the input parameters that were provided.
     * Evaluate an Unleash context against a set of environments and projects.
     */
    async getPlaygroundRaw(requestParameters: GetPlaygroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlaygroundResponseSchema>> {
        if (requestParameters.playgroundRequestSchema === null || requestParameters.playgroundRequestSchema === undefined) {
            throw new runtime.RequiredError('playgroundRequestSchema','Required parameter requestParameters.playgroundRequestSchema was null or undefined when calling getPlayground.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/playground`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlaygroundRequestSchemaToJSON(requestParameters.playgroundRequestSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaygroundResponseSchemaFromJSON(jsonValue));
    }

    /**
     * Use the provided `context`, `environment`, and `projects` to evaluate toggles on this Unleash instance. Returns a list of all toggles that match the parameters and what they evaluate to. The response also contains the input parameters that were provided.
     * Evaluate an Unleash context against a set of environments and projects.
     */
    async getPlayground(requestParameters: GetPlaygroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlaygroundResponseSchema> {
        const response = await this.getPlaygroundRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getProjectHealthOverviewRaw(requestParameters: GetProjectHealthOverviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthOverviewSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getProjectHealthOverview.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthOverviewSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getProjectHealthOverview(requestParameters: GetProjectHealthOverviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthOverviewSchema> {
        const response = await this.getProjectHealthOverviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getProjectHealthReportRaw(requestParameters: GetProjectHealthReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthReportSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getProjectHealthReport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/health-report`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthReportSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getProjectHealthReport(requestParameters: GetProjectHealthReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthReportSchema> {
        const response = await this.getProjectHealthReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getProjectsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectsSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getProjects(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectsSchema> {
        const response = await this.getProjectsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getRawFeatureMetricsRaw(requestParameters: GetRawFeatureMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureMetricsSchema>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getRawFeatureMetrics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/client-metrics/features/{name}/raw`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureMetricsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getRawFeatureMetrics(requestParameters: GetRawFeatureMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureMetricsSchema> {
        const response = await this.getRawFeatureMetricsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getStrategyRaw(requestParameters: GetStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StrategySchema>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StrategySchemaFromJSON(jsonValue));
    }

    /**
     */
    async getStrategy(requestParameters: GetStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StrategySchema> {
        const response = await this.getStrategyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTagRaw(requestParameters: GetTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagWithVersionSchema>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getTag.');
        }

        if (requestParameters.value === null || requestParameters.value === undefined) {
            throw new runtime.RequiredError('value','Required parameter requestParameters.value was null or undefined when calling getTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tags/{type}/{value}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"value"}}`, encodeURIComponent(String(requestParameters.value))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagWithVersionSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getTag(requestParameters: GetTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagWithVersionSchema> {
        const response = await this.getTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTagTypeRaw(requestParameters: GetTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagTypeSchema>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getTagType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tag-types/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagTypeSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getTagType(requestParameters: GetTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagTypeSchema> {
        const response = await this.getTagTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTagTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagTypesSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tag-types`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagTypesSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getTagTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagTypesSchema> {
        const response = await this.getTagTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getTagsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagsSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getTags(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagsSchema> {
        const response = await this.getTagsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getTagsByTypeRaw(requestParameters: GetTagsByTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagsSchema>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getTagsByType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tags/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getTagsByType(requestParameters: GetTagsByTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagsSchema> {
        const response = await this.getTagsByTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getUIConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UiConfigSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/ui-config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UiConfigSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getUIConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UiConfigSchema> {
        const response = await this.getUIConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSchema> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getUsersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersSchemaFromJSON(jsonValue));
    }

    /**
     */
    async getUsers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersSchema> {
        const response = await this.getUsersRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async listTagsRaw(requestParameters: ListTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagsSchema>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling listTags.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/features/{featureName}/tags`.replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async listTags(requestParameters: ListTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagsSchema> {
        const response = await this.listTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async overwriteFeatureVariantsRaw(requestParameters: OverwriteFeatureVariantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureVariantsSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling overwriteFeatureVariants.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling overwriteFeatureVariants.');
        }

        if (requestParameters.variantSchema === null || requestParameters.variantSchema === undefined) {
            throw new runtime.RequiredError('variantSchema','Required parameter requestParameters.variantSchema was null or undefined when calling overwriteFeatureVariants.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/variants`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.variantSchema.map(VariantSchemaToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureVariantsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async overwriteFeatureVariants(requestParameters: OverwriteFeatureVariantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureVariantsSchema> {
        const response = await this.overwriteFeatureVariantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async patchFeatureRaw(requestParameters: PatchFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling patchFeature.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling patchFeature.');
        }

        if (requestParameters.patchSchema === null || requestParameters.patchSchema === undefined) {
            throw new runtime.RequiredError('patchSchema','Required parameter requestParameters.patchSchema was null or undefined when calling patchFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.patchSchema.map(PatchSchemaToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async patchFeature(requestParameters: PatchFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.patchFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async patchFeatureStrategyRaw(requestParameters: PatchFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureStrategySchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling patchFeatureStrategy.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling patchFeatureStrategy.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling patchFeatureStrategy.');
        }

        if (requestParameters.strategyId === null || requestParameters.strategyId === undefined) {
            throw new runtime.RequiredError('strategyId','Required parameter requestParameters.strategyId was null or undefined when calling patchFeatureStrategy.');
        }

        if (requestParameters.patchSchema === null || requestParameters.patchSchema === undefined) {
            throw new runtime.RequiredError('patchSchema','Required parameter requestParameters.patchSchema was null or undefined when calling patchFeatureStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))).replace(`{${"strategyId"}}`, encodeURIComponent(String(requestParameters.strategyId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.patchSchema.map(PatchSchemaToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureStrategySchemaFromJSON(jsonValue));
    }

    /**
     */
    async patchFeatureStrategy(requestParameters: PatchFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureStrategySchema> {
        const response = await this.patchFeatureStrategyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async patchFeatureVariantsRaw(requestParameters: PatchFeatureVariantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureVariantsSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling patchFeatureVariants.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling patchFeatureVariants.');
        }

        if (requestParameters.patchSchema === null || requestParameters.patchSchema === undefined) {
            throw new runtime.RequiredError('patchSchema','Required parameter requestParameters.patchSchema was null or undefined when calling patchFeatureVariants.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/variants`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.patchSchema.map(PatchSchemaToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureVariantsSchemaFromJSON(jsonValue));
    }

    /**
     */
    async patchFeatureVariants(requestParameters: PatchFeatureVariantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureVariantsSchema> {
        const response = await this.patchFeatureVariantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async reactivateStrategyRaw(requestParameters: ReactivateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.strategyName === null || requestParameters.strategyName === undefined) {
            throw new runtime.RequiredError('strategyName','Required parameter requestParameters.strategyName was null or undefined when calling reactivateStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies/{strategyName}/reactivate`.replace(`{${"strategyName"}}`, encodeURIComponent(String(requestParameters.strategyName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async reactivateStrategy(requestParameters: ReactivateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reactivateStrategyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async removeEnvironmentFromProjectRaw(requestParameters: RemoveEnvironmentFromProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling removeEnvironmentFromProject.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling removeEnvironmentFromProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/environments/{environment}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async removeEnvironmentFromProject(requestParameters: RemoveEnvironmentFromProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeEnvironmentFromProjectRaw(requestParameters, initOverrides);
    }

    /**
     */
    async removeStrategyRaw(requestParameters: RemoveStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling removeStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async removeStrategy(requestParameters: RemoveStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeStrategyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async removeTagRaw(requestParameters: RemoveTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling removeTag.');
        }

        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling removeTag.');
        }

        if (requestParameters.value === null || requestParameters.value === undefined) {
            throw new runtime.RequiredError('value','Required parameter requestParameters.value was null or undefined when calling removeTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/features/{featureName}/tags/{type}/{value}`.replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"value"}}`, encodeURIComponent(String(requestParameters.value))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async removeTag(requestParameters: RemoveTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeTagRaw(requestParameters, initOverrides);
    }

    /**
     */
    async resetUserPasswordRaw(requestParameters: ResetUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResetPasswordSchema>> {
        if (requestParameters.idSchema === null || requestParameters.idSchema === undefined) {
            throw new runtime.RequiredError('idSchema','Required parameter requestParameters.idSchema was null or undefined when calling resetUserPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/reset-password`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IdSchemaToJSON(requestParameters.idSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResetPasswordSchemaFromJSON(jsonValue));
    }

    /**
     */
    async resetUserPassword(requestParameters: ResetUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResetPasswordSchema> {
        const response = await this.resetUserPasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async reviveFeatureRaw(requestParameters: ReviveFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling reviveFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/archive/revive/{featureName}`.replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async reviveFeature(requestParameters: ReviveFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reviveFeatureRaw(requestParameters, initOverrides);
    }

    /**
     */
    async searchUsersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersSchema>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersSchemaFromJSON(jsonValue));
    }

    /**
     */
    async searchUsers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersSchema> {
        const response = await this.searchUsersRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async toggleEnvironmentOffRaw(requestParameters: ToggleEnvironmentOffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling toggleEnvironmentOff.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/environments/{name}/off`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async toggleEnvironmentOff(requestParameters: ToggleEnvironmentOffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.toggleEnvironmentOffRaw(requestParameters, initOverrides);
    }

    /**
     */
    async toggleEnvironmentOnRaw(requestParameters: ToggleEnvironmentOnRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling toggleEnvironmentOn.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/environments/{name}/on`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async toggleEnvironmentOn(requestParameters: ToggleEnvironmentOnRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.toggleEnvironmentOnRaw(requestParameters, initOverrides);
    }

    /**
     */
    async toggleFeatureEnvironmentOffRaw(requestParameters: ToggleFeatureEnvironmentOffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling toggleFeatureEnvironmentOff.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling toggleFeatureEnvironmentOff.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling toggleFeatureEnvironmentOff.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/off`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async toggleFeatureEnvironmentOff(requestParameters: ToggleFeatureEnvironmentOffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.toggleFeatureEnvironmentOffRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async toggleFeatureEnvironmentOnRaw(requestParameters: ToggleFeatureEnvironmentOnRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling toggleFeatureEnvironmentOn.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling toggleFeatureEnvironmentOn.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling toggleFeatureEnvironmentOn.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/on`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async toggleFeatureEnvironmentOn(requestParameters: ToggleFeatureEnvironmentOnRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.toggleFeatureEnvironmentOnRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateAddonRaw(requestParameters: UpdateAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddonSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateAddon.');
        }

        if (requestParameters.addonSchema === null || requestParameters.addonSchema === undefined) {
            throw new runtime.RequiredError('addonSchema','Required parameter requestParameters.addonSchema was null or undefined when calling updateAddon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/addons/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddonSchemaToJSON(requestParameters.addonSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddonSchemaFromJSON(jsonValue));
    }

    /**
     */
    async updateAddon(requestParameters: UpdateAddonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddonSchema> {
        const response = await this.updateAddonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateApiTokenRaw(requestParameters: UpdateApiTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling updateApiToken.');
        }

        if (requestParameters.updateApiTokenSchema === null || requestParameters.updateApiTokenSchema === undefined) {
            throw new runtime.RequiredError('updateApiTokenSchema','Required parameter requestParameters.updateApiTokenSchema was null or undefined when calling updateApiToken.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/api-tokens/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateApiTokenSchemaToJSON(requestParameters.updateApiTokenSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateApiToken(requestParameters: UpdateApiTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateApiTokenRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateContextFieldRaw(requestParameters: UpdateContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contextField === null || requestParameters.contextField === undefined) {
            throw new runtime.RequiredError('contextField','Required parameter requestParameters.contextField was null or undefined when calling updateContextField.');
        }

        if (requestParameters.upsertContextFieldSchema === null || requestParameters.upsertContextFieldSchema === undefined) {
            throw new runtime.RequiredError('upsertContextFieldSchema','Required parameter requestParameters.upsertContextFieldSchema was null or undefined when calling updateContextField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/context/{contextField}`.replace(`{${"contextField"}}`, encodeURIComponent(String(requestParameters.contextField))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertContextFieldSchemaToJSON(requestParameters.upsertContextFieldSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateContextField(requestParameters: UpdateContextFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateContextFieldRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateFeatureRaw(requestParameters: UpdateFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureSchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling updateFeature.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling updateFeature.');
        }

        if (requestParameters.updateFeatureSchema === null || requestParameters.updateFeatureSchema === undefined) {
            throw new runtime.RequiredError('updateFeatureSchema','Required parameter requestParameters.updateFeatureSchema was null or undefined when calling updateFeature.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFeatureSchemaToJSON(requestParameters.updateFeatureSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureSchemaFromJSON(jsonValue));
    }

    /**
     */
    async updateFeature(requestParameters: UpdateFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureSchema> {
        const response = await this.updateFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateFeatureStrategyRaw(requestParameters: UpdateFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeatureStrategySchema>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling updateFeatureStrategy.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling updateFeatureStrategy.');
        }

        if (requestParameters.environment === null || requestParameters.environment === undefined) {
            throw new runtime.RequiredError('environment','Required parameter requestParameters.environment was null or undefined when calling updateFeatureStrategy.');
        }

        if (requestParameters.strategyId === null || requestParameters.strategyId === undefined) {
            throw new runtime.RequiredError('strategyId','Required parameter requestParameters.strategyId was null or undefined when calling updateFeatureStrategy.');
        }

        if (requestParameters.updateFeatureStrategySchema === null || requestParameters.updateFeatureStrategySchema === undefined) {
            throw new runtime.RequiredError('updateFeatureStrategySchema','Required parameter requestParameters.updateFeatureStrategySchema was null or undefined when calling updateFeatureStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"featureName"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"environment"}}`, encodeURIComponent(String(requestParameters.environment))).replace(`{${"strategyId"}}`, encodeURIComponent(String(requestParameters.strategyId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFeatureStrategySchemaToJSON(requestParameters.updateFeatureStrategySchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureStrategySchemaFromJSON(jsonValue));
    }

    /**
     */
    async updateFeatureStrategy(requestParameters: UpdateFeatureStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeatureStrategySchema> {
        const response = await this.updateFeatureStrategyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateFeedbackRaw(requestParameters: UpdateFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeedbackSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateFeedback.');
        }

        if (requestParameters.feedbackSchema === null || requestParameters.feedbackSchema === undefined) {
            throw new runtime.RequiredError('feedbackSchema','Required parameter requestParameters.feedbackSchema was null or undefined when calling updateFeedback.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/feedback/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FeedbackSchemaToJSON(requestParameters.feedbackSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeedbackSchemaFromJSON(jsonValue));
    }

    /**
     */
    async updateFeedback(requestParameters: UpdateFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeedbackSchema> {
        const response = await this.updateFeedbackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateSortOrderRaw(requestParameters: UpdateSortOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateSortOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/environments/sort-order`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateSortOrder(requestParameters: UpdateSortOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateSortOrderRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateSplashSettingsRaw(requestParameters: UpdateSplashSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SplashSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateSplashSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/splash/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SplashSchemaFromJSON(jsonValue));
    }

    /**
     */
    async updateSplashSettings(requestParameters: UpdateSplashSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SplashSchema> {
        const response = await this.updateSplashSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateStrategyRaw(requestParameters: UpdateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.strategyName === null || requestParameters.strategyName === undefined) {
            throw new runtime.RequiredError('strategyName','Required parameter requestParameters.strategyName was null or undefined when calling updateStrategy.');
        }

        if (requestParameters.upsertStrategySchema === null || requestParameters.upsertStrategySchema === undefined) {
            throw new runtime.RequiredError('upsertStrategySchema','Required parameter requestParameters.upsertStrategySchema was null or undefined when calling updateStrategy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/strategies/{strategyName}`.replace(`{${"strategyName"}}`, encodeURIComponent(String(requestParameters.strategyName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertStrategySchemaToJSON(requestParameters.upsertStrategySchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateStrategy(requestParameters: UpdateStrategyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateStrategyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateTagTypeRaw(requestParameters: UpdateTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateTagType.');
        }

        if (requestParameters.updateTagTypeSchema === null || requestParameters.updateTagTypeSchema === undefined) {
            throw new runtime.RequiredError('updateTagTypeSchema','Required parameter requestParameters.updateTagTypeSchema was null or undefined when calling updateTagType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tag-types/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTagTypeSchemaToJSON(requestParameters.updateTagTypeSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateTagType(requestParameters: UpdateTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTagTypeRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateUserRaw(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateUser.');
        }

        if (requestParameters.updateUserSchema === null || requestParameters.updateUserSchema === undefined) {
            throw new runtime.RequiredError('updateUserSchema','Required parameter requestParameters.updateUserSchema was null or undefined when calling updateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateUserSchemaToJSON(requestParameters.updateUserSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSchemaFromJSON(jsonValue));
    }

    /**
     */
    async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSchema> {
        const response = await this.updateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async validateRaw(requestParameters: ValidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.nameSchema === null || requestParameters.nameSchema === undefined) {
            throw new runtime.RequiredError('nameSchema','Required parameter requestParameters.nameSchema was null or undefined when calling validate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/context/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NameSchemaToJSON(requestParameters.nameSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async validate(requestParameters: ValidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.validateRaw(requestParameters, initOverrides);
    }

    /**
     */
    async validateConstraintRaw(requestParameters: ValidateConstraintRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.constraintSchema === null || requestParameters.constraintSchema === undefined) {
            throw new runtime.RequiredError('constraintSchema','Required parameter requestParameters.constraintSchema was null or undefined when calling validateConstraint.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/constraints/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConstraintSchemaToJSON(requestParameters.constraintSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async validateConstraint(requestParameters: ValidateConstraintRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.validateConstraintRaw(requestParameters, initOverrides);
    }

    /**
     */
    async validateFeatureRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/features/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async validateFeature(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.validateFeatureRaw(initOverrides);
    }

    /**
     */
    async validateTagTypeRaw(requestParameters: ValidateTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValidateTagTypeSchema>> {
        if (requestParameters.tagTypeSchema === null || requestParameters.tagTypeSchema === undefined) {
            throw new runtime.RequiredError('tagTypeSchema','Required parameter requestParameters.tagTypeSchema was null or undefined when calling validateTagType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/tag-types/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TagTypeSchemaToJSON(requestParameters.tagTypeSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValidateTagTypeSchemaFromJSON(jsonValue));
    }

    /**
     */
    async validateTagType(requestParameters: ValidateTagTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValidateTagTypeSchema> {
        const response = await this.validateTagTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async validateUserPasswordRaw(requestParameters: ValidateUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.passwordSchema === null || requestParameters.passwordSchema === undefined) {
            throw new runtime.RequiredError('passwordSchema','Required parameter requestParameters.passwordSchema was null or undefined when calling validateUserPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // apiKey authentication
        }

        const response = await this.request({
            path: `/api/admin/user-admin/validate-password`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordSchemaToJSON(requestParameters.passwordSchema),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async validateUserPassword(requestParameters: ValidateUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.validateUserPasswordRaw(requestParameters, initOverrides);
    }

}
